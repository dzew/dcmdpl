import matplotlib.pyplot as pt
import funcs
import graphs
import math
import random
import smoothing as sm
import vfplotter as vfp

def makePlot(ys, numx1, numx2):
    Z = [[ys[i + j*numx1] for i in xrange(numx1)] for j in xrange(numx2)]
    vfp.showSurface(Z)

def distortion(xs, df):
    def ret(i, j):
        d = df(xs[i], xs[j]) / sm.dist(xs[i], xs[j])
        if d > 1:
            d = 1./d
            return (1 - d ** 3, 0, 0)
        return (0, 0, 1 - d ** 3)
    return ret

# The VCM relaxation described in the paper
# Arguments:
#    xs    - the x coordinates of the data
#    ys    - f(x) for x in xs
#    tf    - \tilde f, approximation generated by kernel regresison
#    df    - a metric
#    alpha - relaxation rate
def davr(xs, ys, tf, df, alpha):
    cache = {}
    dx = max([max([sm.dist(x1,x2) for x2 in xs]) for x1 in xs])
    dy = max(ys) - min(ys)
    a = alpha * alpha
    def ret(x1, x2):
        if (x1,x2) in cache:
            return cache[(x1,x2)]
        xdf = df(x1,x2)**2
        ydf = a * (abs(tf(x1)-tf(x2)) * dx / dy) ** 2
        res = ((xdf + ydf)/(1 + a))**.5
        cache[(x1,x2)] = res
        cache[(x2,x1)] = res
        return res
    return ret

def graphTf(xs, ys, df, alpha):
    dy = max(ys) - min(ys)
    dx = max([max([sm.dist(x1,x2) for x2 in xs]) for x1 in xs])
    d = {x:i for i,x in enumerate(xs)}
    a = alpha * alpha
    def nmdf(x1,x2,y1,y2):
        xdf = df(x1,x2)**2
        ydf = a * (abs(y1-y2) * dx / dy) ** 2
        return (xdf + ydf) **.5 / (1 + a)**.5
    mat = [[nmdf(x1,x2,y1,y2) for x2,y2 in zip(xs,ys)] for x1,y1 in zip(xs,ys)]
    
    def ret(x1,x2):
        return mat[d[x1]][d[x2]]
    return ret

#gph2 = graphs.gridGraph(numx1, numx2)
n = 40
xs = [ i/(n-1.) for i in xrange(n)]
#xs = [random.random() for i in xrange(n)]
#xs.sort()
#gph = graphs.completeGraph(n)

b = .15
t = 40
alpha = .4

allys = []
alldfs = []
errs = []
yts = []
f = lambda x : -(1-x) ** .5 * math.cos(x * 3 * 3.1416)
#f = funcs.bumpy
fname = 'Unspecified function'
ys = [f(x) for x in xs]
#ndf = lambda x1,x2 : abs(f(x1) - f(x2))**.25#sm.dist
ndf = sm.dist
#pt.plot(xs, ys, 'y', linewidth = 3, label='f')

mer = 999.99
sup = None
mey = None
mlim = None

errs = []
for a,m in zip([ .25, .5, 1., 2.],'o*D+'):
    errs = []
    ndf = sm.dist
    tf = f
    for i in xrange(t):
        k = sm.tfKernel(ndf, sm.gaussian)
        tf = sm.nadWatson(xs,f,k,b)
        yt = [tf(x) for x in xs]
        #yt = sm.model(xs, f, k, b)
        allys.append(yt)
        ndf = davr(xs, ys, tf, ndf, a)
        #ndf = graphTf(xs, yt, ndf, a)
        alldfs.append(ndf)
        errs.append(sm.error(ys, yt))
        if errs[-1] < mer:
            mer = errs[-1]
            sup = a
            mey = yt
        #print 'error: ', errs[-1]
    print 'done ', a, min(errs)/errs[0]
    yts.append(yt)
    if a == sup:
        mlim = yt
    pt.plot([x/errs[0] for x in errs], '-'+m,label = 'alpha='+str(a))
pt.ylabel('Error')
pt.xlabel('Iteration')
pt.title('FDK approximation error')
pt.legend()
pt.show()

'''
for i in xrange(t):
    k = sm.tfKernel(ndf, sm.gaussian)
    yt = sm.model(xs, f, k, b)
    allys.append(yt)
    ndf = graphTf(xs, yt, ndf, alpha)
    alldfs.append(ndf)
    errs.append(sm.error(ys, yt))
    print 'error: ', errs[-1]
    #pt.plot(xs, yt)
    makePlot(yt, numx1, numx2)'''
    
#miner = min(xrange(len(errs)), key = lambda x : errs[x])
pt.scatter(xs, ys, c='k', label='Input Data')
pt.plot(xs, allys[0], 'b--', linewidth=2, label='Kernel Smoother Fit')
pt.plot(xs, mey, 'r-', linewidth=2, label='Best FDK Fit')
pt.plot(xs, mlim, 'g+-', label='FDK Limit')
pt.title('FDK approximation with b=' + str(b))
pt.legend(loc = 'best')
pt.ylim(min(ys)-.1, max(ys)+.1)
pt.xlim(min(xs), max(xs))
pt.show()
#makePlot(allys[0], numx1, numx2)
#makePlot(yt, numx1, numx2)
#vfp.graph(xs, gph, distortion(xs, ndf), 3)
